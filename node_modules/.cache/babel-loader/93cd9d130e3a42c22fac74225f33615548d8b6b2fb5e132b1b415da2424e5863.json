{"ast":null,"code":"import React from 'react';\nimport { bool, func, node, number, object, oneOfType, string } from 'prop-types';\nvar debounce = function debounce(fn, time) {\n  var timeout = void 0;\n  return function () {\n    var _this = this,\n      _arguments = arguments;\n    var functionCall = function functionCall() {\n      return fn.apply(_this, _arguments);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n};\n\n// https://stackoverflow.com/questions/6860853/generate-random-string-for-div-id#6860916\n\nvar guidGenerator = function () {\n  var S4 = function S4() {\n    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n  };\n  return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();\n};\nfunction getHighest(elements) {\n  var highest = 0;\n  elements.forEach(function (el) {\n    if (el.rect && el.rect.height > highest) {\n      highest = el.rect.height;\n    }\n  });\n  return highest;\n}\nfunction nextTriggerOnMount(_ref) {\n  var rect = _ref.rect,\n    mode = _ref.mode,\n    prevOffset = _ref.prevOffset,\n    position = _ref.position,\n    direction = _ref.direction,\n    width = _ref.width;\n  if (mode !== 'chain') return false;\n  switch (direction) {\n    case 'toRight':\n      return position.from > 0;\n    case 'toLeft':\n    default:\n      return rect.width + position.from <= width;\n  }\n}\nfunction getFromOffset(_ref) {\n  var rect = _ref.rect,\n    offset = _ref.offset,\n    direction = _ref.direction;\n  switch (direction) {\n    case 'toRight':\n      return offset - rect.width;\n    case 'toLeft':\n    default:\n      return offset;\n  }\n}\nfunction getFrom(_ref2) {\n  var index = _ref2.index,\n    rect = _ref2.rect,\n    offset = _ref2.offset,\n    width = _ref2.width,\n    direction = _ref2.direction;\n  if (index === 0) return offset;\n  if (typeof offset === 'number') {\n    return getFromOffset({\n      rect: rect,\n      offset: offset,\n      direction: direction\n    });\n  }\n  switch (direction) {\n    case 'toRight':\n      return -rect.width;\n    case 'toLeft':\n    default:\n      return width;\n  }\n}\nfunction getTo(_ref3) {\n  var rect = _ref3.rect,\n    width = _ref3.width,\n    direction = _ref3.direction;\n  switch (direction) {\n    case 'toRight':\n      return width;\n    case 'toLeft':\n    default:\n      return -rect.width;\n  }\n}\nfunction getNext(_ref4) {\n  var mode = _ref4.mode,\n    from = _ref4.from,\n    direction = _ref4.direction,\n    rect = _ref4.rect,\n    width = _ref4.width;\n  var start = from || 0;\n  switch (mode) {\n    case 'await':\n      switch (direction) {\n        case 'toRight':\n          return width;\n        case 'toLeft':\n        default:\n          return -rect.width;\n      }\n    case 'smooth':\n      switch (direction) {\n        case 'toRight':\n          return rect.width > width ? 0 : width - rect.width;\n        case 'toLeft':\n        default:\n          return rect.width > width ? width - rect.width : 0;\n      }\n    case 'chain':\n    default:\n      switch (direction) {\n        case 'toRight':\n          return 0;\n        case 'toLeft':\n        default:\n          return rect.width + start > width ? width - rect.width : width - rect.left - rect.width;\n      }\n  }\n}\nvar getPosition = function (_ref5) {\n  var mode = _ref5.mode,\n    index = _ref5.index,\n    rect = _ref5.rect,\n    offset = _ref5.offset,\n    width = _ref5.width,\n    direction = _ref5.direction;\n  var from = getFrom({\n    index: index,\n    rect: rect,\n    offset: offset,\n    width: width,\n    direction: direction\n  });\n  var to = getTo({\n    rect: rect,\n    width: width,\n    direction: direction\n  });\n  return {\n    from: from,\n    to: to,\n    next: getNext({\n      mode: mode,\n      from: from,\n      direction: direction,\n      rect: rect,\n      width: width\n    })\n  };\n};\nfunction getNextOffset(_ref) {\n  var from = _ref.from,\n    rect = _ref.rect,\n    direction = _ref.direction;\n  switch (direction) {\n    case 'toRight':\n      {\n        return from;\n      }\n    case 'toLeft':\n    default:\n      {\n        return from + rect.width;\n      }\n  }\n}\nfunction getStartOffset(_ref) {\n  var offset = _ref.offset,\n    rect = _ref.rect,\n    direction = _ref.direction,\n    width = _ref.width;\n  if (offset === 'run-in') {\n    switch (direction) {\n      case 'toRight':\n        return -rect.width;\n      case 'toLeft':\n      default:\n        return width;\n    }\n  }\n  if (typeof offset === 'string') {\n    var offsetRelative = Number(offset.replace('%', ''));\n    if (offsetRelative) return width / 100 * offsetRelative;\n  }\n  return offset;\n}\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\nvar TickerElement = function (_React$Component) {\n  inherits(TickerElement, _React$Component);\n  function TickerElement() {\n    var _ref;\n    var _temp, _this, _ret;\n    classCallCheck(this, TickerElement);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TickerElement.__proto__ || Object.getPrototypeOf(TickerElement)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      children: _this.props.children({\n        index: _this.props.index\n      }),\n      move: _this.props.move,\n      position: {\n        from: undefined,\n        to: undefined,\n        next: undefined\n      },\n      offset: _this.props.offset,\n      rect: null\n    }, _this.x = 0, _this.isMoving = false, _this.nextTriggered = false, _this.elementRef = React.createRef(), _this.raf = null, _this.componentDidMount = function () {\n      _this.setPosition(true);\n      _this.observer = new MutationObserver(_this.onMutation);\n      _this.observer.observe(_this.elementRef.current, {\n        characterData: true,\n        childList: true,\n        subtree: true\n      });\n    }, _this.componentWillUnmount = function () {\n      _this.observer.disconnect();\n    }, _this.onMutation = function () {\n      _this.setPosition();\n    }, _this.componentDidUpdate = function (prevProps, prevState) {\n      if (!_this.x && prevState.position.from !== _this.state.position.from) {\n        _this.x = _this.state.position.from;\n        _this.elementRef.current.style.transform = 'translate3d(' + _this.x + 'px, 0, 0)';\n      }\n      if (_this.x !== _this.state.position.from && prevProps.prevRect && _this.props.prevRect && prevProps.prevRect.width !== _this.props.prevRect.width) {\n        if (_this.props.offset) {\n          _this.x = _this.x + (_this.props.offset - prevProps.offset);\n        } else {\n          _this.x = _this.x + (_this.props.prevRect.width - prevProps.prevRect.width);\n        }\n        _this.elementRef.current.style.transform = 'translate3d(' + _this.x + 'px, 0, 0)';\n      }\n      if (_this.props.move && !prevProps.start && _this.props.start) {\n        _this.animate();\n      }\n      if (_this.props.start && !prevProps.move && _this.props.move) {\n        _this.animate();\n      }\n      if (prevProps.move && !_this.props.move) {\n        _this.isMoving = false;\n        window.cancelAnimationFrame(_this.raf);\n      }\n    }, _this.setPosition = function (isMount) {\n      var _this$props = _this.props,\n        mode = _this$props.mode,\n        width = _this$props.width,\n        id = _this$props.id,\n        onNext = _this$props.onNext,\n        direction = _this$props.direction,\n        index = _this$props.index,\n        setRect = _this$props.setRect;\n      var rect = _this.elementRef.current.getBoundingClientRect();\n      if (rect.width === 0) return;\n      var offset = _this.props.index === 0 ? getStartOffset({\n        offset: _this.props.offset,\n        rect: rect,\n        direction: direction,\n        width: width\n      }) : _this.props.offset;\n      var position = getPosition({\n        mode: mode,\n        rect: rect,\n        index: index,\n        offset: offset,\n        width: width,\n        direction: direction\n      });\n      setRect({\n        index: _this.props.index,\n        rect: rect,\n        offset: offset,\n        nextOffset: getNextOffset({\n          from: position.from,\n          rect: rect,\n          direction: direction\n        })\n      });\n      if (isMount) {\n        var nextTriggerOnMount$$1 = nextTriggerOnMount({\n          mode: mode,\n          rect: rect,\n          position: position,\n          offset: offset,\n          direction: direction,\n          width: width\n        });\n        if (nextTriggerOnMount$$1) {\n          onNext({\n            id: id,\n            index: index,\n            rect: rect,\n            nextOffset: getNextOffset({\n              from: position.from,\n              rect: rect,\n              direction: direction\n            })\n          });\n        }\n        if (!nextTriggerOnMount$$1 && (offset || index === 0)) {\n          onNext({\n            id: id,\n            index: index,\n            rect: rect\n          });\n        }\n        _this.nextTriggered = nextTriggerOnMount$$1;\n      }\n      _this.setState({\n        rect: rect,\n        offset: offset,\n        position: position\n      });\n    }, _this.shouldTriggerNext = function () {\n      if (_this.nextTriggered) return false;\n      return _this.props.direction === 'toLeft' ? _this.x <= _this.state.position.next : _this.x >= _this.state.position.next;\n    }, _this.triggerNext = function () {\n      if (_this.shouldTriggerNext()) {\n        // if (this.props.index === 5) console.log(this.x)\n        _this.nextTriggered = true;\n        _this.props.onNext({\n          id: _this.props.id,\n          index: _this.props.index,\n          rect: _this.state.rect\n        });\n      }\n    }, _this.shouldFinish = function () {\n      switch (_this.props.direction) {\n        case 'toRight':\n          return _this.x >= _this.state.position.to;\n        case 'toLeft':\n        default:\n          return _this.x <= _this.state.position.to;\n      }\n    }, _this.animate = function () {\n      if (_this.isMoving) return;\n      _this.isMoving = true;\n      var prevTimestamp = null;\n      var step = function step(timestamp) {\n        if (!_this.isMoving) return;\n        if (!_this.elementRef.current) return;\n        var progress = prevTimestamp ? timestamp - prevTimestamp : 0;\n        _this.x = _this.props.direction === 'toLeft' ? _this.x - progress / 100 * _this.props.speed : _this.x + progress / 100 * _this.props.speed;\n        _this.elementRef.current.style.transform = 'translate3d(' + _this.x + 'px, 0, 0)';\n        _this.triggerNext();\n        if (_this.shouldFinish()) {\n          _this.isMoving = false;\n          prevTimestamp = null;\n          _this.props.onFinish(_this.props.id);\n        } else {\n          prevTimestamp = timestamp;\n          _this.raf = window.requestAnimationFrame(step);\n        }\n      };\n      _this.raf = window.requestAnimationFrame(step);\n    }, _this.render = function () {\n      return React.createElement('div', {\n        className: 'ticker__element',\n        style: {\n          willChange: 'transform',\n          position: 'absolute',\n          left: 0,\n          top: 0,\n          transform: 'translate3d(' + _this.x + 'px, 0, 0)'\n        },\n        ref: _this.elementRef\n      }, _this.state.children);\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  return TickerElement;\n}(React.Component);\nTickerElement.propTypes = {\n  children: oneOfType([node, func]).isRequired,\n  direction: string.isRequired,\n  speed: number.isRequired,\n  id: string.isRequired,\n  index: number.isRequired,\n  mode: string.isRequired,\n  move: bool.isRequired,\n  onNext: func.isRequired,\n  onFinish: func.isRequired,\n  setRect: func.isRequired,\n  start: bool.isRequired,\n  offset: oneOfType([number, string]),\n  prevRect: object,\n  width: number\n};\nTickerElement.defaultProps = {\n  offset: undefined,\n  width: undefined,\n  prevRect: null\n};\nvar getDefaultState = function getDefaultState(offset, width) {\n  return {\n    elements: [{\n      id: guidGenerator(),\n      index: 0,\n      height: 0,\n      start: false,\n      offset: offset,\n      rect: null,\n      prevRect: null\n    }],\n    width: width,\n    height: 0\n  };\n};\nvar Ticker = function (_React$Component) {\n  inherits(Ticker, _React$Component);\n  function Ticker() {\n    var _ref;\n    var _temp, _this, _ret;\n    classCallCheck(this, Ticker);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call.apply(_ref, [this].concat(args))), _this), _this.next = null, _this.state = getDefaultState(_this.props.offset), _this.tickerRef = React.createRef(), _this.dOnResize = debounce(function () {\n      return _this.onResize();\n    }, 150), _this.componentDidMount = function () {\n      _this.setState({\n        width: _this.tickerRef.current.offsetWidth,\n        height: _this.props.height\n      });\n      window.addEventListener('resize', _this.dOnResize);\n    }, _this.componentWillUnmount = function () {\n      window.removeEventListener('resize', _this.dOnResize);\n    }, _this.setRect = function (_ref2) {\n      var index = _ref2.index,\n        rect = _ref2.rect,\n        offset = _ref2.offset,\n        nextOffset = _ref2.nextOffset;\n      _this.setState(function (prevState) {\n        var elements = prevState.elements.map(function (el) {\n          var newEl = el;\n          if (el.index === index) newEl.rect = rect;\n          // next element\n          if (el.index === index + 1) {\n            newEl.prevRect = rect;\n            if (newEl.offset) {\n              newEl.offset = nextOffset;\n            }\n          }\n          return newEl;\n        });\n        return {\n          elements: elements,\n          height: _this.props.height ? prevState.height : getHighest(elements)\n        };\n      });\n    }, _this.onResize = function () {\n      if (!_this.tickerRef.current || _this.tickerRef.current.offsetWidth === _this.state.width) return;\n      _this.setState(_extends({}, getDefaultState(_this.props.offset, _this.tickerRef.current.offsetWidth), {\n        height: _this.props.height\n      }));\n    }, _this.onFinish = function (id) {\n      _this.props.onFinish();\n      _this.setState(function (prevState) {\n        return {\n          elements: prevState.elements.filter(function (el) {\n            return el.id !== id;\n          })\n        };\n      });\n    }, _this.onNext = function (_ref3) {\n      var id = _ref3.id,\n        index = _ref3.index,\n        rect = _ref3.rect,\n        nextOffset = _ref3.nextOffset;\n      _this.props.onNext(index);\n      _this.setState(function (prevState) {\n        return {\n          elements: [].concat(toConsumableArray(prevState.elements.map(function (el) {\n            var newEl = el;\n            if (el.index === index) newEl.rect = rect;\n            if (el.index === 0 || el.offset || newEl.index === index + 1) {\n              newEl.start = true;\n            }\n            return newEl;\n            // create new element\n          })), [{\n            id: guidGenerator(),\n            index: prevState.elements[prevState.elements.length - 1].index + 1,\n            height: 0,\n            start: false,\n            offset: nextOffset,\n            rect: null,\n            prevRect: rect\n          }])\n        };\n      });\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  createClass(Ticker, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n      return React.createElement('div', {\n        className: 'ticker',\n        ref: this.tickerRef,\n        style: {\n          position: 'relative',\n          overflow: 'hidden',\n          height: this.state.height && this.state.height + 'px'\n        }\n      }, this.state.width && this.state.elements.map(function (el) {\n        return React.createElement(TickerElement, {\n          key: el.id,\n          id: el.id,\n          index: el.index,\n          start: el.start,\n          offset: el.offset,\n          prevRect: el.prevRect,\n          direction: _this2.props.direction,\n          mode: _this2.props.mode,\n          move: _this2.props.move,\n          speed: _this2.props.speed,\n          onFinish: _this2.onFinish,\n          onNext: _this2.onNext,\n          setRect: _this2.setRect,\n          width: _this2.state.width\n        }, _this2.props.children);\n      }));\n    }\n  }]);\n  return Ticker;\n}(React.Component);\nTicker.propTypes = {\n  children: oneOfType([node, func]).isRequired,\n  direction: string,\n  mode: string,\n  move: bool,\n  offset: oneOfType([number, string]),\n  speed: number,\n  height: oneOfType([number, string]),\n  onNext: func,\n  onFinish: func\n};\nTicker.defaultProps = {\n  offset: 0,\n  speed: 5,\n  direction: 'toLeft',\n  mode: 'chain',\n  move: true,\n  height: undefined,\n  onNext: function onNext() {},\n  onFinish: function onFinish() {}\n};\nexport default Ticker;","map":{"version":3,"names":["debounce","fn","time","timeout","functionCall","apply","_this","_arguments","setTimeout","guidGenerator","S4","Math","random","toString","substring","getHighest","elements","highest","forEach","el","rect","height","nextTriggerOnMount","_ref","mode","prevOffset","position","direction","width","from","getFromOffset","offset","getFrom","_ref2","index","getTo","_ref3","getNext","_ref4","start","left","getPosition","_ref5","to","getNextOffset","getStartOffset","offsetRelative","Number","replace","TickerElement","_React$Component","state","props","children","move","undefined","next","x","isMoving","nextTriggered","elementRef","React","createRef","raf","componentDidMount","setPosition","observer","MutationObserver","onMutation","observe","current","characterData","childList","subtree","componentWillUnmount","disconnect","componentDidUpdate","prevProps","prevState","style","transform","prevRect","animate","cancelAnimationFrame","isMount","_this$props","id","onNext","setRect","getBoundingClientRect","nextTriggerOnMount$$1","setState","shouldTriggerNext","triggerNext","shouldFinish","prevTimestamp","step","timestamp","progress","speed","onFinish","window","requestAnimationFrame","render","createElement","Component","propTypes","oneOfType","node","func","isRequired","string","number","bool","object","defaultProps","getDefaultState","Ticker","tickerRef","dOnResize","onResize","offsetWidth","addEventListener","removeEventListener","nextOffset","map","newEl","_extends","filter","length","_this2"],"sources":["D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\debounce.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\guidGenerator.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\getHighest.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\shouldNextTriggerOnMount.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\getPosition.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\getNextOffset.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\getStartOffset.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\Element.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\utils\\getDefaultState.js","D:\\orts\\srts\\node_modules\\react-ticker\\src\\index.js"],"sourcesContent":["const debounce = (fn, time) => {\n  let timeout\n\n  return function () {\n    const functionCall = () => fn.apply(this, arguments)\n\n    clearTimeout(timeout)\n    timeout = setTimeout(functionCall, time)\n  }\n}\n\nexport default debounce\n","// https://stackoverflow.com/questions/6860853/generate-random-string-for-div-id#6860916\n\nexport default () => {\n  const S4 = () => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1)\n  return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4())\n}\n","export default function getHighest(elements) {\n  let highest = 0\n  elements.forEach(el => {\n    if (el.rect && el.rect.height > highest) {\n      highest = el.rect.height\n    }\n  })\n  return highest\n}\n","export default function nextTriggerOnMount({ rect, mode, prevOffset, position, direction, width }) {\n  if (mode !== 'chain') return false\n  switch (direction) {\n    case 'toRight':\n      return position.from > 0\n    case 'toLeft':\n    default:\n      return rect.width + position.from <= width\n  }\n}\n","function getFromOffset({ rect, offset, direction }) {\n  switch (direction) {\n    case 'toRight':\n      return offset - rect.width\n    case 'toLeft':\n    default:\n      return offset\n  }\n}\n\nfunction getFrom({ index, rect, offset, width, direction }) {\n  if (index === 0) return offset\n\n  if (typeof offset === 'number') {\n    return getFromOffset({ rect, offset, direction })\n  }\n\n  switch (direction) {\n    case 'toRight':\n      return -rect.width\n    case 'toLeft':\n    default:\n      return width\n  }\n}\n\nfunction getTo({ rect, width, direction }) {\n  switch (direction) {\n    case 'toRight':\n      return width\n    case 'toLeft':\n    default:\n      return -rect.width\n  }\n}\n\nfunction getNext({ mode, from, direction, rect, width }) {\n  const start = from || 0\n\n  switch (mode) {\n    case 'await':\n      switch (direction) {\n        case 'toRight':\n          return width\n        case 'toLeft':\n        default:\n          return -rect.width\n      }\n    case 'smooth':\n      switch (direction) {\n        case 'toRight':\n          return rect.width > width\n            ? 0\n            : width - rect.width\n        case 'toLeft':\n        default:\n          return rect.width > width\n            ? width - rect.width\n            : 0\n      }\n    case 'chain':\n    default:\n      switch (direction) {\n        case 'toRight':\n          return 0\n        case 'toLeft':\n        default:\n          return rect.width + start > width\n            ? width - rect.width\n            : width - rect.left - rect.width\n      }\n  }\n}\n\nexport default ({ mode, index, rect, offset, width, direction }) => {\n  const from = getFrom({ index, rect, offset, width, direction })\n  const to = getTo({ rect, width, direction })\n  return {\n    from,\n    to,\n    next: getNext({ mode, from, direction, rect, width })\n  }\n}\n","export default function getNextOffset({ from, rect, direction }) {\n  switch (direction) {\n    case 'toRight': {\n      return from\n    }\n    case 'toLeft':\n    default: {\n      return from + rect.width\n    }\n  }\n}\n","export default function getStartOffset({ offset, rect, direction, width }) {\n  if (offset === 'run-in') {\n    switch (direction) {\n      case 'toRight':\n        return -rect.width\n      case 'toLeft':\n      default:\n        return width\n    }\n  }\n  if (typeof offset === 'string') {\n    const offsetRelative = Number(offset.replace('%', ''))\n    if (offsetRelative) return (width / 100) * offsetRelative\n  }\n  return offset\n}\n","import React from 'react'\nimport { bool, func, node, number, object, oneOfType, string } from 'prop-types'\n\nimport shouldNextTriggerOnMount from './utils/shouldNextTriggerOnMount'\nimport getPosition from './utils/getPosition'\nimport getNextOffset from './utils/getNextOffset'\nimport getStartOffset from './utils/getStartOffset'\n\nclass TickerElement extends React.Component {\n  static propTypes = {\n    children: oneOfType([node, func]).isRequired,\n    direction: string.isRequired,\n    speed: number.isRequired,\n    id: string.isRequired,\n    index: number.isRequired,\n    mode: string.isRequired,\n    move: bool.isRequired,\n    onNext: func.isRequired,\n    onFinish: func.isRequired,\n    setRect: func.isRequired,\n    start: bool.isRequired,\n\n    offset: oneOfType([number, string]),\n    prevRect: object,\n    width: number\n  }\n\n  static defaultProps = {\n    offset: undefined,\n    width: undefined,\n    prevRect: null\n  }\n\n  state = {\n    children: this.props.children({\n      index: this.props.index\n    }),\n    move: this.props.move,\n    position: { from: undefined, to: undefined, next: undefined },\n    offset: this.props.offset,\n    rect: null\n  }\n  x = 0\n  isMoving = false\n  nextTriggered = false\n  elementRef = React.createRef()\n  raf = null\n\n  componentDidMount = () => {\n    this.setPosition(true)\n    this.observer = new MutationObserver(this.onMutation)\n    this.observer.observe(this.elementRef.current, { characterData: true, childList: true, subtree: true })\n  }\n\n  componentWillUnmount = () => {\n    this.observer.disconnect()\n  }\n\n  onMutation = () => {\n    this.setPosition()\n  }\n\n  componentDidUpdate = (prevProps, prevState) => {\n    if (!this.x && prevState.position.from !== this.state.position.from) {\n      this.x = this.state.position.from\n      this.elementRef.current.style.transform = `translate3d(${this.x}px, 0, 0)`\n    }\n    if (this.x !== this.state.position.from &&\n      prevProps.prevRect &&\n      this.props.prevRect &&\n      prevProps.prevRect.width !== this.props.prevRect.width) {\n      if (this.props.offset) {\n        this.x = this.x + (this.props.offset - prevProps.offset)\n      } else {\n        this.x = this.x + (this.props.prevRect.width - prevProps.prevRect.width)\n      }\n      this.elementRef.current.style.transform = `translate3d(${this.x}px, 0, 0)`\n    }\n    if (this.props.move && !prevProps.start && this.props.start) {\n      this.animate()\n    }\n    if (this.props.start && !prevProps.move && this.props.move) {\n      this.animate()\n    }\n    if (prevProps.move && !this.props.move) {\n      this.isMoving = false\n      window.cancelAnimationFrame(this.raf)\n    }\n  }\n\n  setPosition = (isMount) => {\n    const {\n      mode,\n      width,\n      id,\n      onNext,\n      direction,\n      index,\n      setRect\n    } = this.props\n\n    const rect = this.elementRef.current.getBoundingClientRect()\n    if (rect.width === 0) return\n\n    const offset = this.props.index === 0\n      ? getStartOffset({ offset: this.props.offset, rect, direction, width })\n      : this.props.offset\n\n    const position = getPosition({ mode, rect, index, offset, width, direction })\n\n    setRect({\n      index: this.props.index,\n      rect,\n      offset,\n      nextOffset: getNextOffset({ from: position.from, rect, direction })\n    })\n\n    if (isMount) {\n      const nextTriggerOnMount = shouldNextTriggerOnMount({ mode, rect, position, offset, direction, width })\n      if (nextTriggerOnMount) {\n        onNext({\n          id,\n          index,\n          rect,\n          nextOffset: getNextOffset({ from: position.from, rect, direction })\n        })\n      }\n      if (!nextTriggerOnMount && (offset || index === 0)) {\n        onNext({ id, index, rect })\n      }\n      this.nextTriggered = nextTriggerOnMount\n    }\n\n    this.setState({\n      rect,\n      offset,\n      position\n    })\n  }\n\n  shouldTriggerNext = () => {\n    if (this.nextTriggered) return false\n    return this.props.direction === 'toLeft'\n      ? this.x <= this.state.position.next\n      : this.x >= this.state.position.next\n  }\n\n  triggerNext = () => {\n    if (this.shouldTriggerNext()) {\n      // if (this.props.index === 5) console.log(this.x)\n      this.nextTriggered = true\n      this.props.onNext({\n        id: this.props.id,\n        index: this.props.index,\n        rect: this.state.rect\n      })\n    }\n  }\n\n  shouldFinish = () => {\n    switch (this.props.direction) {\n      case 'toRight':\n        return this.x >= this.state.position.to\n      case 'toLeft':\n      default:\n        return this.x <= this.state.position.to\n    }\n  }\n\n  animate = () => {\n    if (this.isMoving) return\n    this.isMoving = true\n\n    let prevTimestamp = null\n\n    const step = (timestamp) => {\n      if (!this.isMoving) return\n      if (!this.elementRef.current) return\n\n      const progress = prevTimestamp\n        ? timestamp - prevTimestamp\n        : 0\n\n      this.x = this.props.direction === 'toLeft'\n        ? this.x - (progress / 100 * this.props.speed)\n        : this.x + (progress / 100 * this.props.speed)\n      this.elementRef.current.style.transform = `translate3d(${this.x}px, 0, 0)`\n      this.triggerNext()\n\n      if (this.shouldFinish()) {\n        this.isMoving = false\n        prevTimestamp = null\n        this.props.onFinish(this.props.id)\n      } else {\n        prevTimestamp = timestamp\n        this.raf = window.requestAnimationFrame(step)\n      }\n    }\n    this.raf = window.requestAnimationFrame(step)\n  }\n\n  render = () => (\n    <div\n      className='ticker__element'\n      style={{\n        willChange: 'transform',\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        transform: `translate3d(${this.x}px, 0, 0)`\n      }}\n      ref={this.elementRef}\n    >\n      {this.state.children}\n    </div>\n  )\n}\n\nexport default TickerElement\n","\nimport guidGenerator from './guidGenerator'\n\nconst getDefaultState = (offset, width) => ({\n  elements: [{\n    id: guidGenerator(),\n    index: 0,\n    height: 0,\n    start: false,\n    offset: offset,\n    rect: null,\n    prevRect: null\n  }],\n  width,\n  height: 0\n})\n\nexport default getDefaultState\n","import React from 'react'\nimport {bool, func, node, number, oneOfType, string} from 'prop-types'\nimport debounce from './utils/debounce'\nimport guidGenerator from './utils/guidGenerator'\nimport getHighest from './utils/getHighest'\nimport TickerElement from './Element'\nimport getDefaultState from './utils/getDefaultState'\n\nexport default class Ticker extends React.Component {\n  static propTypes = {\n    children: oneOfType([node, func]).isRequired,\n\n    direction: string,\n    mode: string,\n    move: bool,\n    offset: oneOfType([number, string]),\n    speed: number,\n    height: oneOfType([number, string]),\n    onNext: func,\n    onFinish: func\n  }\n\n  static defaultProps = {\n    offset: 0,\n    speed: 5,\n    direction: 'toLeft',\n    mode: 'chain',\n    move: true,\n    height: undefined,\n    onNext: () => {},\n    onFinish: () => {}\n  }\n  next = null\n  state = getDefaultState(this.props.offset)\n  tickerRef = React.createRef()\n\n  dOnResize = debounce(() => this.onResize(), 150)\n\n  componentDidMount = () => {\n    this.setState({\n      width: this.tickerRef.current.offsetWidth,\n      height: this.props.height\n    })\n    window.addEventListener('resize', this.dOnResize)\n  }\n\n  componentWillUnmount = () => {\n    window.removeEventListener('resize', this.dOnResize)\n  }\n\n  setRect = ({index, rect, offset, nextOffset}) => {\n    this.setState(prevState => {\n      const elements = prevState.elements.map(el => {\n        const newEl = el\n        if (el.index === index) newEl.rect = rect\n        // next element\n        if (el.index === index + 1) {\n          newEl.prevRect = rect\n          if (newEl.offset) {\n            newEl.offset = nextOffset\n          }\n        }\n        return newEl\n      })\n      return {\n        elements,\n        height: this.props.height\n          ? prevState.height\n          : getHighest(elements)\n      }\n    })\n  }\n\n  onResize = () => {\n    if (!this.tickerRef.current || this.tickerRef.current.offsetWidth === this.state.width) return\n    this.setState({\n      ...getDefaultState(this.props.offset, this.tickerRef.current.offsetWidth),\n      height: this.props.height\n    })\n  }\n\n  onFinish = (id) => {\n    this.props.onFinish()\n    this.setState(prevState => ({\n      elements: prevState.elements.filter(el => el.id !== id)\n    }))\n  }\n\n  onNext = ({id, index, rect, nextOffset}) => {\n    this.props.onNext(index)\n\n    this.setState(prevState => ({\n      elements: [\n        // start next element\n        ...prevState.elements.map(el => {\n          const newEl = el\n          if (el.index === index) newEl.rect = rect\n          if (el.index === 0 || el.offset || newEl.index === index + 1) {\n            newEl.start = true\n          }\n          return newEl\n          // create new element\n        }), {\n          id: guidGenerator(),\n          index: prevState.elements[prevState.elements.length - 1].index + 1,\n          height: 0,\n          start: false,\n          offset: nextOffset,\n          rect: null,\n          prevRect: rect\n        }\n      ]\n    }))\n  }\n\n  render() {\n\n    return (\n      <div\n        className='ticker'\n        ref={this.tickerRef}\n        style={{\n          position: 'relative',\n          overflow: 'hidden',\n          height: this.state.height && `${this.state.height}px`\n        }}\n      >\n        {\n          this.state.width && this.state.elements.map(el => {\n            return (\n              <TickerElement\n                key={el.id}\n                id={el.id}\n                index={el.index}\n                start={el.start}\n                offset={el.offset}\n                prevRect={el.prevRect}\n\n                direction={this.props.direction}\n                mode={this.props.mode}\n                move={this.props.move}\n                speed={this.props.speed}\n\n                onFinish={this.onFinish}\n                onNext={this.onNext}\n                setRect={this.setRect}\n                width={this.state.width}\n              >\n                {this.props.children}\n              </TickerElement>\n            )\n          })\n        }\n      </div>\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}